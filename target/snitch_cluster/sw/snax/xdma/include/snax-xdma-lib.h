// Copyright 2024 KU Leuven.
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Yunhao Deng <yunhao.deng@kuleuven.be>

#pragma once
#include <stdbool.h>
#include "snrt.h"
#include "stdint.h"

// Define the CSR address of xdma, should be generated by scala
#include "snax-xdma-addr.h"

// Define the base address of XDMA CSRIO
#define XDMA_CFG_ADDR 960
static inline uint32_t snax_read_xdma_cfg_reg(uint32_t addr) {
    return csrr_ss(XDMA_CFG_ADDR + addr);
}
static inline void snax_write_xdma_cfg_reg(uint32_t addr, uint32_t value) {
    csrw_ss(XDMA_CFG_ADDR + addr, value);
}

// Data Copy Task
int32_t snax_xdma_memcpy_nd_full_addr(
    uint64_t src, uint64_t dst, uint32_t spatial_stride_src,
    uint32_t spatial_stride_dst, uint32_t temp_dim_src,
    uint32_t* temp_stride_src, uint32_t* temp_bound_src, uint32_t temp_dim_dst,
    uint32_t* temp_stride_dst, uint32_t* temp_bound_dst,
    uint32_t enabled_chan_src, uint32_t enabled_chan_dst,
    uint32_t enabled_byte_dst);

int32_t snax_xdma_memcpy_nd(void* src, void* dst, uint32_t spatial_stride_src,
                            uint32_t spatial_stride_dst, uint32_t temp_dim_src,
                            uint32_t* temp_stride_src, uint32_t* temp_bound_src,
                            uint32_t temp_dim_dst, uint32_t* temp_stride_dst,
                            uint32_t* temp_bound_dst, uint32_t enabled_chan_src,
                            uint32_t enabled_chan_dst,
                            uint32_t enabled_byte_dst);

int32_t snax_xdma_memcpy_1d_full_addr(uint64_t src, uint64_t dst,
                                      uint32_t size);

int32_t snax_xdma_memcpy_1d(void* src, void* dst, uint32_t size);

// Multicast Task
int32_t snax_xdma_multicast_nd_full_address(
    uint64_t src, uint64_t* dst, uint32_t dst_num, uint32_t spatial_stride_src,
    uint32_t spatial_stride_dst, uint32_t temp_dim_src,
    uint32_t* temp_stride_src, uint32_t* temp_bound_src, uint32_t temp_dim_dst,
    uint32_t* temp_stride_dst, uint32_t* temp_bound_dst,
    uint32_t enabled_chan_src, uint32_t enabled_chan_dst,
    uint32_t enabled_byte_dst);

int32_t snax_xdma_multicast_nd(
    void* src, void** dst, uint32_t dst_num, uint32_t spatial_stride_src,
    uint32_t spatial_stride_dst, uint32_t temp_dim_src,
    uint32_t* temp_stride_src, uint32_t* temp_bound_src, uint32_t temp_dim_dst,
    uint32_t* temp_stride_dst, uint32_t* temp_bound_dst,
    uint32_t enabled_chan_src, uint32_t enabled_chan_dst,
    uint32_t enabled_byte_dst);

int32_t snax_xdma_multicast_1d_full_address(uint64_t src, uint64_t* dst,
                                            uint32_t dst_num, uint32_t size);

int32_t snax_xdma_multicast_1d(void* src, void** dst, uint32_t dst_num,
                               uint32_t size);

// Extension
int32_t snax_xdma_xdma_enable_src_ext(uint8_t ext, uint32_t* csr_value);
int32_t snax_xdma_disable_src_ext(uint8_t ext);
int32_t snax_xdma_enable_dst_ext(uint8_t ext, uint32_t* csr_value);
int32_t snax_xdma_disable_dst_ext(uint8_t ext);

// Start
static inline uint32_t snax_xdma_start() {
    uint32_t local_task_id = snax_read_xdma_cfg_reg(XDMA_COMMIT_LOCAL_TASK_PTR);
    uint32_t remote_task_id = snax_read_xdma_cfg_reg(XDMA_COMMIT_REMOTE_TASK_PTR);
    snax_write_xdma_cfg_reg(XDMA_START_PTR, 1);
    while (1) {
        // Wait for xdma to start
        if (snax_read_xdma_cfg_reg(XDMA_COMMIT_LOCAL_TASK_PTR) !=
            local_task_id) {
            return snax_read_xdma_cfg_reg(XDMA_COMMIT_LOCAL_TASK_PTR);
        }
        if (snax_read_xdma_cfg_reg(XDMA_COMMIT_REMOTE_TASK_PTR) !=
            remote_task_id) {
            return snax_read_xdma_cfg_reg(XDMA_COMMIT_REMOTE_TASK_PTR);
        }
    }
}

// Wait xdma to finished
static inline void snax_xdma_local_wait(uint32_t task_id) {
    while (snax_read_xdma_cfg_reg(XDMA_FINISH_LOCAL_TASK_PTR) < task_id) {
        // Wait for xdma to finish
    }
}

static inline void snax_xdma_remote_wait(uint32_t task_id) {
    while (snax_read_xdma_cfg_reg(XDMA_FINISH_REMOTE_TASK_PTR) < task_id) {
        // Wait for xdma to finish
    }
}

static inline uint32_t snax_xdma_last_task_cycle() {
    return snax_read_xdma_cfg_reg(XDMA_PERF_CTR_TASK);
}

static inline uint32_t snax_xdma_last_read_cycle() {
    return snax_read_xdma_cfg_reg(XDMA_PERF_CTR_READER);
}

static inline uint32_t snax_xdma_last_write_cycle() {
    return snax_read_xdma_cfg_reg(XDMA_PERF_CTR_WRITER);
}
